\documentclass[a4paper,11pt]{report}
\usepackage{hyperref}
\usepackage{appendix}
\usepackage{listings}
\usepackage{fancybox}
\usepackage{graphicx}
\graphicspath{ {images/} }
\usepackage{parskip}
\usepackage{index}
\makeindex
\makeatletter
\newcommand{\head}[1]{\textbf{#1}}
\newenvironment{CenteredBox}{% 
\begin{Sbox}}{% Save the content in a box
\end{Sbox}\centerline{\parbox{\wd\@Sbox}{\TheSbox}}}% And output it centered
\makeatother
\lstset{
	basicstyle=\ttfamily\scriptsize,
	breaklines=true,
}
\renewcommand{\bibname}{References}
\begin{document}
\begin{titlepage}
	\centering
	{\bfseries Component Based MMIX Simulator using Multiple Programming Paradigms \par}
	\vspace{1cm}
	{A dissertation submitted in partial fulfillment of the requirements for the MSc in Advanced Computing Technologies\par}
	\vspace{1.5cm}
	{by Stephen Edmans\par}
	\vspace{2cm}
	{Department of Computer Science and Information Systems\par}
	{Birkbeck College, University of London\par}
	\vspace{2cm}
	{\large September 2015\par}
\end{titlepage}
\newpage
\chapter*{} % Academic Declaration
{This report is substantially the result of my own work except where explicitly
indicated in the text. I give my permission for it to be submitted to the JISC
Plagiarism Detection Service. I have read and understood the sections on plagiarism
in the Programme Handbook and the College website.\par}
\vspace{1cm}
{\noindent The report may be freely copied and distributed provided the source is explicitly
acknowledged.}
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

There are currently over 2,500\footnote{From the language list\cite{numlangs}} different programming languages, with more created every year. These programming languages can get grouped together in numerous different ways.  This makes the decision of what language to use when starting a new project extremely difficult.

There are several ways in which we can reach this decision; choose the language that your team knows best; choose the language that makes the most sense to implement the critical part of your system; choose a simple general purpose language; choose a language that has got an active community. There is no acknowledged best approach to take.

Another approach would be to split your application up into separate components and using a different programming language for each component. This allows us choose the most appropriate programming language for each component.

The purpose of this project is to examine this approach. The application that we will create will be a simulator for an artificial machine language. The artificial machine language that we will use is called MMIX, it was developed by Donald Knuth as part of his seminal work The Art of Computer Programming\cite{knuth:aocp1}.
\newpage
\addcontentsline{toc}{chapter}{Contents}
\tableofcontents
\newpage
\listoffigures
\newpage
\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}
\chapter{Introduction}
As software systems get larger and more complex there is a need to handle this complexity. There is a prevailing design paradigm, which addresses these issues, that is to break these systems up into smaller components.  This is a sentiment mentioned by Turner~\cite{turner:why}  He calls these components ``collections of modules'', these components will interact with each other to make the complete system. 

When you have control over the development of more than one of these components it is a traditional approach to use a single programming paradigm for your components. There is, however, no reason that you cannot use different languages and paradigms for these for each components. The goal of this project is to create a relatively complex system that is made up of multiple components where each component uses the most appropriate programming paradigm for the relevant component.

The system that we have created in this project was inspired by Jeliot~\cite{jeliot:ref}, which is a tool that is used as an aid in the teaching of Java. The Jeliot system allows a user to give it a piece of Java source code and it will show the user what the underlying java virtual machine is doing when it runs the code.

In his seminal work The Art of Computer Programming~\cite{knuth:aocp1} Professor Donald Knuth designed an artificial machine language that he called MIX. In a later volume of his work Professor Knuth updated this machine architecture, which he calls MMIX. He later detailed this new version of the architecture in a fascicle~\cite{knuth:aocp2}. This project will create a system that take MMIX assembly code and shows the user, graphically, what the simulated machine is doing.

\chapter{Assembler}
\section{Introduction}
The first component that we developed takes a text file containing the MMIX assembly language code and translated it into a binary representation of the code.  This component it typically called a \textit{compiler}, to quote \cite{dragon}

\begin{quote}
A compiler is a program that can read a program in one language -- the \textit{source} language -- and translate it into an equivalent program in another language -- the \textit{target} language.
\end{quote}

A compiler operates as a series of phases, each of which transforms one representation of the source program into another. A typical decomposition of a compiler into phases, taken from \cite{dragon} is shown in Figure~\ref{CompilerPhases}.
\begin{figure}[ht!]
\centering
\includegraphics[width=\textwidth]{PhasesOfACompiler}
\caption{Phases of a compiler}
\label{CompilerPhases}
\end{figure}

A number if these phases are used to convert a higher level language down into a specific machine language.  In this project we already start with a machine language, which means that we do not need these phases. A program that takes an assembly language file and translates it into machine language is typically called an \textit{assembler}.

The four phases that we need for our project are Lexical Analysis, Syntax Analysis, Semantic Analysis and Code Generation. There are two of these phases, syntax analysis and semantic analysis, which are usually combined into a single phase, which is typically called a \textit{Parser}.

The first thing that we need to do is decide which programming language is the most appropriate for this component. The component takes a fixed input and always produces the same output. The component does not contain any user interaction and it does not need a user interface. These requirements led us to choose a functional language for this component. The language we chose was Haskell.

We describe how each of these phases are implemented in the next few sections.
\section{Lexer}
The initial phase of compilation, lexical analysis, takes a stream of characters and converts them into tokens. Lexical analysis is a well know problem and there are many tools that have been created to make this task simpler. 
\section{Parser}
\section{Code Generation}
\subsection{Symbol Table}
\subsection{Automatically Assigned Registers}
\subsection{Local Symbols}
%What is a local symbol
%How do we achieve this?
%Convert all #H statements with system generated labels that cannot be used by the user (??LS#H*) Where # is the local label number and * is a counter
%Unclear what to do if local symbol defined on line where it could be used.
\subsection{Handling Operands}
\subsection{Assembler Directives}
\subsection{Generating the Output}
\section{Executable}
%% HOW WE RUN THE ASSEMBLER, WHAT THE PARAMETERS ARE & WHAT THE OUTPUT IS
\section{Component Testing}
%% DO I NEED A SECTION HERE TO TALK ABOUT ANY ISSUES AND THOUGHTS RESULTING IN THE DEVELOPMENT, ALONG WITH THE INTEGRATION OF THE PARTS
\chapter{Graphical User Interface}
\section{Introduction}
\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{GUISample}
\caption{GUI Sample Screen shot}
\end{figure}

\section{User Interface Design}
\subsection{Console Panel}
\subsection{Controls Panel}
\subsection{Main State Panel}
\subsection{Memory Panel}
\subsection{Registers Panel}
\section[Asynchronous UI Programming with Actors]{Asynchronous User Interface Programming with Actors}
\section{Communication}
\section{Component Testing}
\chapter{Virtual Machine}
\section{Introduction}
All definition of an MMIX computer come directly from either \cite{knuth:aocp1} or \cite{knuth:aocp2}

Architecture of a computer  %% FIND QUOTATION
CPU, ALU, Memory, Secondary Storage, IO Devices

The virtual machine we are developing will only consist of a CPU and memory.

The way that memory is organized can be considered a hierarchy, to quote Aho et al\cite{dragon}
\begin{quotation}
A memory hierarchy consists of several levels of storage with different speeds and sizes, with the levels closest to the processor being the fastest but smallest... Memory hierarchies are found in all machines. A processor usually has a small number of registers consisting of hundreds of bytes, several levels of caches containing kilobytes to megabytes, physical memory containing megabytes to gigabytes, and finally secondary storage that contains gigabytes and beyond.
\end{quotation}
For this project we will only be considering the physical memory and the registers.

\section{Memory}
Wyde

\begin{math}
M_2[0] = M_2[1] = M[0]M[1]
\end{math}

Tetra

\begin{math}
M_4[4k] = M_4[4k+1] = ... = M_4[4k+3] = M[4k]M[4k+1]...M[4k+3]
\end{math}

Octa

\begin{math}
M_8[8k] = M_8[8k+1] = ... = M_8[8k+7] = M[8k]M[8k+1]...M[8k+7]
\end{math}

\section{Registers}
An MMIX computer contains two distinct types of registers, 256 general purpose registers and 32 special purpose registers. A complete list of the special registers can be found in Figure~\ref{fig:spec_regs}

\begin{figure}[ht!]
\begin{center}
\begin{tabular}{ c l }
\head{Identifier} & \head{Description}\\
rA & Arithmetic Status Register\\
rB & Bootstrap Register\\
rC & Continuation Register\\
rD & Dividend Register\\
rE & Epsilon Register\\
rF & Failure Location Register\\
rG & Global Threshold Register\\
rH & Himult Register\\
rI & Interval Counter\\
rJ & Return-Jump Register\\
rK & Interrupt Mask Register\\
rL & Local Threshold Register\\
rM & Multiplex Mask Register\\
rN & Serial Number\\
rO & Register Stack Offset\\
rP & Prediction Register\\
rQ & Interrupt Request Register\\
rR & Remainder Register\\
rS & Register Stack Pointer\\
rT & Trap Address Register\\
rU & Usage Counter\\
rV & Virtual Translation Register\\
rW & Where Interrupted Register\\
rX & Execution Register\\
rY & Y Operand\\
rZ & Z Operand\\
rBB & Bootstrap Register\\
rTT & Dynamic Trap Address Register\\
rWW & Where Interrupted Register\\
rXX & Execution Register\\
rYY & Y Operand\\
rZZ & Z Operand\\
\end{tabular}
\end{center}
\caption{Special Registers}
\label{fig:spec_regs}
\end{figure}
rA Arithmetic Status Register

least significant byte contains eight event bits. DVWIOUZX

\begin{center}
\begin{tabular}{ c l }
\head{Register} & \head{Description}\\
D & Integer Divide Check\\
V & Integer Overflow\\
W & Float-to-Fix Overflow\\
I & Invalid Operation\\
O & Floating Overflow\\
U & Floating Underflow\\
Z & Division by Zero\\
X & Floating Inexact\\
\end{tabular}
\end{center}

The next least significant byte contains eight ``enable'' bits with the same name DVWIOUZX and the same meanings.  

When an exceptional condition occurs, there are two cases: If the corresponding enable bit is 0, the corresponding event bit is set to 1; but if the corresponding enable bit is 1, MMIX interrupts its current instruction stream and execute a special ``exception handler''.  Thus, the event bits record exceptions that have not been ``tripped''.

This leaves six high order bytes.  At present, only  two of those 48 bits are defined. The two bits corresponding to 
\begin{math}
2^{17}
\end{math}
and 
\begin{math}
2^{16}
\end{math}
in rA specify a rounding mode, as follows: -

\begin{center}
\begin{tabular}{ c l }
00 & Round to the nearest\\
01 & Round off\\
10 & Round up\\
11 & Round down\\
\end{tabular}
\end{center}

\section{Central Processing Unit}
\section{Calling the Operating System}
\section{Communication}
\section{Component Testing}
\chapter{Simulator Application}
\section{Introduction}
%% HOW THE APPLICATION AS A WHOLE WORKS
\section{Integration Testing}
\subsection{Generate Prime Numbers Sample Application}
\chapter*{Conclusion}
\addcontentsline{toc}{chapter}{Conclusion}
\nocite{*}
\bibliographystyle{alpha}
\bibliography{bibtex}
\addcontentsline{toc}{chapter}{References}
\begin{appendices}
\noappendicestocpagenum
\addappheadtotoc 
\chapter{Source Code}
\section{Assembler}
\section{Graphical User Interface}
\section{Virtual Machine}
\chapter{Intermediate Assembler Representations}
\section{Definitions}
\section{Test Application}
\subsection{Sample Test MMIXAL Code}
The sample mmixal application I am using to test the system is taken from Fascile 1\cite{knuth:aocp2}.  The complete code listing is

\begin{CenteredBox}
\lstinputlisting{primes.mms}
\end{CenteredBox}
\subsection{Parsed Sample File}
The final version of the parsed source code for the test application is
\lstinputlisting[language=Haskell]{parsed_example.hs}
\end{appendices}
\clearpage
\addcontentsline{toc}{chapter}{Index}
\printindex
\end{document}

