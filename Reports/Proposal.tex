% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

%%% END Article customizations

\title{Component Based MMIX Simulator using Multiple Programming Paradigms}
\author{Stephen Edmans}
\date{} % Activate to display a given date or no date (if empty),

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\listoffigures
\newpage
\section{Introduction}
To quote Hughes~\cite{hughes:why}
\begin{quote}
	As software becomes more and more complex, it is more and more important to structure it well. Well-structured software is easy to write and to debug, and provides a collection of modules that can be reused to reduce future programming costs
\end{quote}
These collections of modules, or components as I will call them, will interact with each other to make the complete system. When you have control over the development of more than one of these components it is traditional to use a single programming paradigm for your components. There is, however, no reason that you cannot use different languages and paradigms for these components. The goal of this project is to create a relatively complex system that is made up of multiple components where each component uses the most appropriate programming paradigm for each component.

The system that I plan to create in this project is inspired by Jeliot, which is a tool that is used as an aid in the teaching of Java. %REFERENCE
The Jeliot system allows a user to give it a piece of Java source code and it will show the user what the underlying virtual machine is doing when it runs the code.

In his seminal work The Art of Computer Programming Dr. Donald Knuth designed an artificial machine language that he called MIX. In a later volume of his work Dr. Knuth updated this machine language, which he calls MMIX. This project will create a system that take MMIX assembly code and shows the user, graphically, what the simulated machine is doing.

% Is it Dr or Prof?
% Is it language or architecture?
% Reference of book

\section{Existing Implementations}

There is already one existing main implementation created by Dr. Knuth and his team at Stanford University. This implementation runs as a few command line utilities.  These utilities include an assembler which converts a text file containing the relevant assembly language source code into a proprietary binary format.  There is a utility which reads files in this proprietary binary format and displays the content back to the console.  There is also the main utility which will execute the application stored in the binary files using an MMIX virtual machine.  It is possible to get the virtual machine to output some tracing information but it does not have a graphical user interface and it does not allow you to step through the processing of the application.  

These utilities are all written in CWEB % DESCRIBE!.

% Reference for Dr. Knuths 
% List the existing implementations that I can find.
% Comment on how they are approaching the process

\section{Outline Design}
The MMIX simulator application will consists of three separate components. The task of converting the MMIX assembly language source text into the corresponding binary representation will be performed by a component I am calling the Assembler. The task of actually simulating an MMIX computer will be performed by a Virtual Machine component. The final component will be responsible for representing the current state of the MMIX computer to the user, along with orchestrating all of the interactions with the other components. I am calling this component the User Interface.  The interactions between the components can be illustrated by figure~\ref{fig:interactionsDiagram}.

One question that needs to be answered is what is the target platform for this application. The application will initially be written for Mac OS X but if there is time available at the end of the development process I would like to make sure this  application will run on other platforms.

\begin{figure}[ht]
	\begin{picture}(200,300)(10,10)
		\put(10,  130){\framebox(150, 50){User Interface}}
		\put(230, 130){\framebox(150, 50){Assembler}}
		\put(10,  10) {\framebox(150, 50){Virtual Machine}}
		\put(160, 165){\vector(1, 0){70}}
		\put(195, 180){\circle{15}}
		\put(192, 177){1}
		\put(230, 145){\vector(-1, 0){70}}
		\put(195, 130){\circle{15}}
		\put(192, 127){2}
		\put(25,  60) {\vector(0, 1){70}}
		\put(10,  95) {\circle{15}}
		\put(7,   92) {3}
		\put(65,  130){\vector(0, -1){70}}
		\put(50,  95) {\circle{15}}
		\put(47,  92) {4}
		\put(105, 60) {\vector(0, 1){70}}
		\put(90,  95) {\circle{15}}
		\put(87,  92) {5}
		\put(145, 130){\vector(0, -1){70}}
		\put(130, 95) {\circle{15}}
		\put(127, 92) {6}
	\end{picture}
	\caption{Component Interactions}
	\label{fig:interactionsDiagram}
\end{figure}

\begin{enumerate}
	\item Source Text
	\item Binary Representation
	\item Binary Representation
	\item Current State
	\item Process Next Step
	\item Change of State
\end{enumerate}

\subsection{Assembler}
% Haskell
% 
The purpose of the assembler component is that it will take in MMIX assembly language source code contained in a source file and convert it into a binary representation of the application.  The first thing that I need to decide upon, for each component, is what is the most appropriate programming paradigm.  The production of an assembler is a fairly well defined process.  There should be little, or preferably, no ambiguity in the translations.  These requirements make me think that this would be an ideal candidate to be written in a functional language.

To quote 
\begin{quote}Functional programming is so called because its fundamental operation is the application of functions to arguments. A main program itself is written as a function that receives the program’s input as its argument and delivers the program’s output as its result.\end{quote}
There are many functional languages available so determining which one to use requires some consideration.  One way to classify functional languages is to determine how easily they allow users to create side effects.

\subsection{Virtual Machine}
% Erlang
%
Reset Simulator
Load Program
Reset Program
Process Next Statement

\subsection{Graphical User Interface}
% (Scala? F#?)
%
The main way that users will interact with the simulator is through a graphical user interface (GUI).  The GUI will be responsible for all of the interactions with the other components. There are three main forms of user interface commonly used at the present time.  The difference between the three are how the user access the application and where the processing occurs.  The traditional method is an application that is installed on the client machine and runs directly on the machine.  The newer approach 

\subsubsection{Programming Paradigm}

\subsubsection{Initial Design}
The GUI can be broken up into 4 separate sections as illustrated in figure~\ref{fig:graphicalUserInterface}

\begin{figure}[ht]
	\begin{picture}(200,300)(10,10)
		\put(0,0){\framebox(450,300){}}
		\put(10, 10){\framebox(100, 280){Registers}}
		\put(120, 10){\framebox(315,30){Simulation Controls}}
		\put(120, 50){\framebox(315, 50){Main Program State}}
		\put(120, 110){\framebox(315, 90){Standard Console}}
		\put(120, 210){\framebox(315, 80){Memory}}
	\end{picture}
	\caption{Graphical User Interface}
	\label{fig:graphicalUserInterface}
\end{figure}

\subsubsection{Memory}
The memory section of the GUI will contain a representation of the simulators current memory.


00000000: 8fff 0100 0000 0701 f4ff 0003 0000 0702 ................
00000010: 0000 0000 2c20 776f 726c 640a 00        ...., world..

\subsubsection{Registers}
The registers section of the GUI will display a list of all of the available registers in the simulated MMIX machine.  It will show not only the names of the registers but there current values.  
\subsubsection{Main Program State}
\subsubsection{Standard Console}
There are a number of embedded computers that do not interact directly with a user however it is quite rare for a general purpose computer to have no interactions.  The MMIX simulator have got standard input and output channels.  These are accessed through the standard console area on the GUI.
\subsection{Simulation Controls}

\section{Development Methodology}

% How am I going to test the application.  
% Test Driven Development.

\section{Development Plan}

% How will I break down the work?
% What milestones and delivery dates do I want to propose

\section{Summary}

% How is my proposed implementation different from the existing implementations.
% Are there any metrics that I can use to compare my implementation with the existing implementations.

\begin{thebibliography}{99}
	\bibitem{hughes:why}John Hughes, The University Glasgow
\end{thebibliography}
http://www.cs.utexas.edu/~shmat/courses/cs345/whyfp.pdf

\end{document}
