% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

%%% END Article customizations

\title{Component Based MMIX Simulator using Multiple Programming Paradigms}
\author{Stephen Edmans}
\date{} % Activate to display a given date or no date (if empty),

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\listoffigures
\newpage
\section{Introduction}
There is a prevailing design paradigm to break systems up into smaller components %REFERENCE
The idea behind this paradigm is that these components can be swapped out for alternatives when the need requires.  They can also be developed in parallel and potentially by separate teams of developers. 
There is now a proliferation of 

\section{Existing Implementations}

% List the existing implementations that I can find.
% Comment on how they are approaching the process

\section{Outline Design}
The MMIX simulator application will consists of three separate components. The task of converting the MMIX assembly language source text into the corresponding binary representation will be performed by a component I am calling the Assembler. The task of actually simulating an MMIX computer will be performed by a component that I am calling the Simulation Engine. The final component will be responsible for representing the current state of the MMIX computer to the user, along with orchestrating all of the interactions with the other components. I am calling this component the User Interface.  The interactions between the components can be illustrated by the .

\begin{figure}[h!]
	\label{fig:interactions}
\begin{picture}(200,200)(10,10)
	\put(10,  130){\framebox(150, 50){User Interface}}
	\put(230, 130){\framebox(150, 50){Assembler}}
	\put(10,  10) {\framebox(150, 50){Simulation Engine}}
	\put(160, 165){\vector(1, 0){70}}
	\put(195, 180){\circle{15}}
	\put(192, 177){1}
	\put(230, 145){\vector(-1, 0){70}}
	\put(195, 130){\circle{15}}
	\put(192, 127){2}
	\put(25,  60) {\vector(0, 1){70}}
	\put(10,  95) {\circle{15}}
	\put(7,   92) {3}
	\put(65,  130){\vector(0, -1){70}}
	\put(50,  95) {\circle{15}}
	\put(47,  92) {4}
	\put(105, 60) {\vector(0, 1){70}}
	\put(90,  95) {\circle{15}}
	\put(87,  92) {5}
	\put(145, 130){\vector(0, -1){70}}
	\put(130, 95) {\circle{15}}
	\put(127, 92) {6}
\end{picture}
	\caption{Component Interaction}
\end{figure}

\begin{enumerate}
	\item Source Text
	\item Binary Representation
	\item Binary Representation
	\item Current State
	\item Process Next Step
	\item Change of State
\end{enumerate}

% Target environment (Windows? Mac? Linux? cross platform?)

\subsection{Assembler}
% Haskell
% 

\subsection{Simulation Engine}
% Erlang
%

\subsection{Graphical User Interface}
% (Scala? F#?)
%

The main way that users will interact with the simulator is through a graphical user interface (GUI).  The GUI will be responsible for all of the interactions with the other components. The GUI can be broken up into 4 separate sections as illustrated in figure

\begin{figure}[h!]
	\label{GUI}
	\begin{picture}(200,300)(10,10)
		\put(0,0){\framebox(450,300){}}
		\put(10, 10){\framebox(100, 280){Registers}}
		\put(120, 10){\framebox(315, 100){Standard Console}}
		\put(120, 120){\framebox(315, 80){Main Program State}}
		\put(120, 210){\framebox(315, 80){Memory}}
	\end{picture}
	\caption{Graphical User Interface}
\end{figure}

\subsubsection{Memory}
\subsubsection{Registers}
\subsubsection{Main Program State}
\subsubsection{Standard Console}
\section{Development Plan}

% How will I break down the work?
% What milestones and delivery dates do I want to propose

\section{Testing}

% How am I going to test the application.  
% Test Driven Development.

\section{Summary}

% How is my proposed implementation different from the existing implementations.
% Are there any metrics that I can use to compare my implementation with the existing implementations.

\end{document}
